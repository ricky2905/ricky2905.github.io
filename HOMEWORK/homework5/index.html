<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>RSA Exposed — RSA Toy & Demo | Riccardo D'Annibale</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Analysis of a flawed letter-by-letter RSA implementation and how frequency analysis can break it; correct implementation notes and C example.">
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #0f111a;
      color: #e0e0e0;
      line-height: 1.8;
      padding: 2rem;
      max-width: 900px;
      margin: auto;
    }

    h1, h2, h3, h4 { color: #4CAF50; }

    h1 {
      font-size: 2.8rem;
      border-bottom: 3px solid #4CAF50;
      padding-bottom: 0.3rem;
      margin: 0 0 1rem 0;
    }
    h2 { font-size: 2rem; margin-top: 1.5rem; }
    h3 { font-size: 1.3rem; margin-top: 1rem; }

    .card {
      background-color: #1a1c2b;
      border-left: 5px solid #4CAF50;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1.5rem 0;
      box-shadow: 0 4px 15px rgba(76,175,80,0.08);
    }

    a { color: #4CAF50; text-decoration: none; }
    a:hover { color: #66bb6a; text-decoration: underline; }

    table { border-collapse: collapse; width: 100%; margin-top: 8px; background: #0f111a; }
    th, td { border: 1px solid rgba(255,255,255,0.06); padding: 8px; text-align: left; font-size: 0.95rem; color: #e7e7e7; }
    th { background: rgba(76,175,80,0.06); color: #dfffe0; }

    pre { background: #0b0c10; color: #dfeee0; padding: 12px; border-radius: 6px; overflow-x: auto; border: 1px solid rgba(255,255,255,0.03); }
    code { background: rgba(255,255,255,0.03); padding: 2px 6px; border-radius: 4px; color: #e8f5e9; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; }

    .small { font-size: 13px; color: #cfd8cf; }

    @media (max-width:600px){
      body { padding: 1rem; max-width: 100%; }
      h1 { font-size: 2rem; }
    }
  </style>

  <script>
    /* Minimal MathJax config (deferred typesetting) if equations present */
    window.MathJax = { tex: { inlineMath: [['\\(','\\)'], ['$', '$']], displayMath: [['\\[','\\]']] }, startup: { typeset: false } };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
</head>
<body>
  <header>
    <nav style="display:flex;gap:12px;margin-bottom:1rem">
      <a href="/">Home</a>
      <a href="/about/">About</a>
    </nav>
  </header>

  <main>

    <article class="card">
      <h1>RSA Exposed: A Statistical Look at Public-Key Encryption</h1>
      <p class="small">Short note: this page analyses a common implementation mistake (applying RSA per letter) and explains why frequency analysis breaks it; it also provides guidance on correct use of RSA and a small C example for block-based encryption/decryption.</p>
    </article>

    <article class="card">
      <h2>Overview of RSA</h2>
      <p>RSA (Rivest–Shamir–Adleman) is a public-key cryptosystem whose security relies on the practical difficulty of factoring a large composite modulus <code>n = p·q</code>. The canonical operations are:</p>
      <ul>
        <li><strong>Key generation:</strong> choose large primes <code>p</code>, <code>q</code>; compute <code>n = p·q</code> and <code>φ(n) = (p−1)(q−1)</code>; pick public exponent <code>e</code> coprime with <code>φ(n)</code>; compute private exponent <code>d ≡ e⁻¹ (mod φ(n))</code>.</li>
        <li><strong>Encryption:</strong> for a message representative <code>M</code> (as an integer with 0 ≤ M &lt; n) compute <code>C ≡ Mᵉ (mod n)</code>.</li>
        <li><strong>Decryption:</strong> compute <code>M ≡ Cᵈ (mod n)</code> to recover the original representative.</li>
      </ul>
      <p class="small">Important: RSA operates on integers (blocks) that represent properly padded messages; it is not intended to be applied naively to individual characters without padding and block formatting.</p>
    </article>

    <article class="card">
      <h2>Exercise premise: letter-by-letter RSA (why it's insecure)</h2>
      <p>Applying the RSA formula independently to each letter (or ASCII byte) creates a deterministic mapping of plaintext symbol → ciphertext symbol. For a fixed public key, the same plaintext symbol always maps to the same ciphertext integer. This situation is essentially a homophonic substitution cipher with a one-to-one map when no randomness/padding is used.</p>
      <p>Consequences:</p>
      <ul>
        <li><strong>Frequency preservation:</strong> symbol frequencies of the plaintext are preserved in the ciphertext (modulo subsequent reduction, e.g. mapping <code>c mod 26</code>). Hence an attacker can exploit statistical regularities (frequency analysis) to map frequent ciphertext symbols to likely plaintext symbols.</li>
        <li><strong>No semantic hiding / no IND-CPA:</strong> modern asymmetric encryption schemes must provide semantic security (indistinguishability under chosen-plaintext attack). Deterministic per-symbol RSA without randomized padding (e.g. OAEP) fails this requirement.</li>
      </ul>
      <p class="small">Takeaway: security of RSA in practice depends as much on correct padding and message formatting (e.g. PKCS#1 v2 / OAEP) as on key sizes and factoring hardness.</p>
    </article>

    <article class="card">
      <h2>How frequency analysis breaks per-symbol RSA</h2>
      <p>Basic attack outline (statistical cryptanalysis):</p>
      <ol>
        <li>Collect ciphertext symbols and compute their empirical frequency distribution.</li>
        <li>Compare with expected plaintext frequencies from a reference corpus (English, Italian, …).</li>
        <li>Construct a candidate mapping by ranking ciphertext symbols and mapping them to letters by descending frequency (most frequent → 'E', second → 'T', etc.).</li>
        <li>Optionally refine the candidate via simple local search (swap two mappings and accept improvements based on language scoring such as dictionary matches, n-gram scores or χ² goodness of fit).</li>
      </ol>
      <p>This attack is effective when the plaintext is long enough for frequency estimates to concentrate and when the mapping is deterministic and small alphabet reductions (e.g. <code>c mod 26</code>) do not sufficiently obscure relative frequencies.</p>
    </article>

    <article class="card">
      <h2>Practical recommendations</h2>
      <ul>
        <li>Do <strong>not</strong> encrypt single characters deterministically with raw RSA. Use hybrid schemes: generate a random symmetric key, encrypt data with a symmetric cipher, then encrypt the symmetric key with RSA (or use authenticated public-key encryption primitives).</li>
        <li>Always use modern padding schemes (OAEP) for RSA encryption and proper signature schemes (PSS) for signatures.</li>
        <li>Use recommended key sizes (e.g., 2048–3072 bits or larger depending on policy and lifetime) and vetted cryptographic libraries rather than home-rolled implementations.</li>
        <li>For educational demos, clearly state limitations and avoid suggesting insecure practices as acceptable in real systems.</li>
      </ul>
    </article>

    <article class="card">
      <h2>Suggested experiments (for coursework)</h2>
      <ol>
        <li>Measure empirical recovery success as a function of plaintext length with per-symbol RSA and single-letter alphabet reductions.</li>
        <li>Compare ranking by χ², simple frequency ranking, and combined language scores (n-grams, dictionary hits) to evaluate refinement strategies.</li>
        <li>Explore the effect of mapping <code>c mod 26</code> versus using the full ciphertext integers on frequency leakage.</li>
        <li>Demonstrate the improvement in secrecy when deterministic per-symbol RSA is replaced with RSA-OAEP or a hybrid approach.</li>
      </ol>
    </article>

    <article class="card">
      <h2>Correct RSA usage: an illustrative C example (block-based)</h2>
      <p class="small">The following compact C example demonstrates modular exponentiation, modular inverse (naïve loop) and a toy block encryption/decryption on an integer. It is educational — production code must use big-integer libraries (e.g., GMP) and proper padding.</p>
      <pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
typedef long long ll;

ll pow_mod(ll base, ll exp, ll mod) {
    ll res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % mod;
        base = (base * base) % mod;
        exp /= 2;
    }
    return res;
}

ll mod_inverse(ll a, ll m) {
    a = a % m;
    for (ll x = 1; x &lt; m; x++) {
        if ((a * x) % m == 1) {
            return x;
        }
    }
    return 1;
}

int main(void) {
    ll p = 53;
    ll q = 59;
    ll e = 3;

    ll n = p * q;
    ll phi_n = (p - 1) * (q - 1);
    
    ll d = mod_inverse(e, phi_n);

    printf("--- RSA Parameters ---\n");
    printf("p = %lld, q = %lld, e = %lld\n", p, q, e);
    printf("Public Key (n, e): (%lld, %lld)\n", n, e);
    printf("Phi(n) = %lld\n", phi_n);
    printf("Private Key (d): %lld\n", d);
    
    ll message = 888;

    printf("\n--- Process ---\n");
    printf("Original Message (M): %lld\n", message);

    ll encrypted = pow_mod(message, e, n);
    printf("Encrypted (C): %lld\n", encrypted);

    ll decrypted = pow_mod(encrypted, d, n);
    printf("Decrypted (M'): %lld\n", decrypted);

    if (message == decrypted) {
        printf("\nSuccess: The message was recovered!\n");
    } else {
        printf("\nError: Decryption failed.\n");
    }
    
    return 0;
}
</code></pre>

      <p class="small">Notes: this example uses native integers for clarity only. Real RSA requires arbitrary-precision arithmetic and robust modular inverse implementations (extended Euclidean algorithm), plus safe padding and constant-time routines.</p>
    </article>

    <article class="card">
      <h2>References</h2>
      <ol>
        <li>Rivest, R. L., Shamir, A., & Adleman, L. (1978). <em>A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</em>. Communications of the ACM.</li>
        <li>Menezes, A., van Oorschot, P., & Vanstone, S. (1996). <em>Handbook of Applied Cryptography</em>. CRC Press.</li>
        <li>Boneh, D. (1999). <em>Twenty Years of Attacks on the RSA Cryptosystem</em>. Notices of the AMS.</li>
        <li>Cover, T. M., & Thomas, J. A. (2006). <em>Elements of Information Theory</em>. Wiley.</li>
      </ol>
    </article>

    <article class="card">
      <h2>Conclusion</h2>
      <p>Applying RSA naively to single characters yields a deterministic substitution that leaks statistical structure and is vulnerable to frequency analysis. The security of public-key encryption in real systems requires correct algorithms, proper padding, careful block formatting and the use of vetted cryptographic libraries. This page is intended for educational use to illustrate the difference between a toy implementation and secure practice.</p>
    </article>

  </main>

  <footer class="small" style="margin-top:18px">© 2025 Riccardo D'Annibale</footer>

  <script>
    // Defer MathJax typesetting until page fully loaded
    document.addEventListener('DOMContentLoaded', () => {
      if (window.MathJax && MathJax.startup && MathJax.startup.promise) {
        MathJax.typesetPromise().catch(e => console.error('MathJax typeset error', e));
      }
    });
  </script>
</body>
</html>
