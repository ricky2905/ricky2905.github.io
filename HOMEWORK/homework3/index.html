
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>RSA Exposed — RSA Toy & Demo | Riccardo D'Annibale (fixed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --bg:#0f111a; --panel:#1a1c2b; --accent:#4CAF50; --muted:#cfd8cf; --glass: rgba(255,255,255,0.03); }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;background-color:var(--bg);color:#e0e0e0;line-height:1.8;padding:2rem;max-width:1100px;margin:auto}
    .topnav{display:flex;gap:1rem;margin-bottom:1rem}
    .topnav a{color:var(--accent);text-decoration:none;font-weight:700}
    .topnav a:hover{color:#66bb6a}
    h1,h2,h3{color:var(--accent)}
    h1{font-size:2.2rem;border-bottom:3px solid var(--accent);padding-bottom:0.3rem;margin:0 0 1rem}
    .card{background-color:var(--panel);border-left:5px solid var(--accent);border-radius:8px;padding:1.25rem;margin:1.25rem 0;box-shadow:0 6px 24px rgba(76,175,80,0.06)}
    .small{font-size:13px;color:var(--muted)}
    label{display:block;margin-top:10px;font-weight:700;color:#dfffe0}
    input, textarea, select{width:100%;padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:#0b0c10;color:#e6f4e6;font-size:14px}
    .controls{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap}
    .code{background:#0b0c10;padding:12px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);color:#dfeee0;overflow:auto}
    .chartRow{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
    .chartCard{flex:1 1 320px;background:#0f111a;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:260px;height:160px;box-sizing:border-box;overflow:hidden}
    .chartCard canvas{width:100%;height:120px;display:block}
    table{border-collapse:collapse;width:100%;margin-top:8px}
    th,td{border:1px solid rgba(255,255,255,0.06);padding:8px;text-align:left;color:#e7e7e7}
    th{background:rgba(76,175,80,0.06);color:#dfffe0}
    pre{background:#0b0c10;color:#dfeee0;padding:12px;border-radius:6px;overflow-x:auto;border:1px solid rgba(255,255,255,0.03)}
    button{padding:8px 12px;border-radius:6px;background:var(--accent);border:0;color:#072;font-weight:700;cursor:pointer}
    .muted{color:var(--muted)}
    @media(max-width:720px){ .controls{flex-direction:column} }

    .mjx-chtml { color: #e0e0e0 !important; font-size:1.02rem !important; line-height:1.25 !important; }
    .display-equation { background: rgba(255,255,255,0.02); padding:10px 12px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); margin:12px 0; }
    .mjx-chtml svg { fill: currentColor !important; }
  </style>

  <script>
    window.MathJax = {
      loader: { load: ['input/tex', 'output/chtml', 'ui/menu'] },
      tex: {
        packages: {'[+]': ['ams']},
        inlineMath: [['\\(','\\)'], ['$', '$']],
        displayMath: [['\\[','\\]']]
      },
      chtml: { scale: 1.02 },
      startup: { typeset: false }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async></script>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
</head>
<body>
  <header class="topnav">
    <a href="/">Home</a>
    <a href="/about/">About</a>
  </header>

  <main>

    <article class="card">
      <h1>RSA Exposed: A Statistical Look at Public-Key Encryption</h1>

      <h2>The RSA algorithm: overview</h2>
      <p>RSA (Rivest, Shamir, Adleman) bases its security on the difficulty of factoring very large numbers.</p>
      <p>The main steps are:</p>
      <ol>
        <li><strong>Key generation</strong>:
          <ul>
            <li>Choose two very large prime numbers, <code>p</code> and <code>q</code> (secret).</li>
            <li>Compute the modulus <code>n = p &middot; q</code> (public).</li>
            <li>Compute <code>phi(n) = (p-1)&middot;(q-1)</code> (secret).</li>
            <li>Choose a public exponent <code>e</code> (often 65537 or 3) coprime with <code>phi(n)</code>.</li>
            <li>Compute the private exponent <code>d</code> such that <code>(d &middot; e) % phi(n) = 1</code>.</li>
          </ul>
        </li>
        <li><strong>Encryption</strong>: for a numeric message <code>M</code> compute <code>C = M^e mod n</code>.</li>
        <li><strong>Decryption</strong>: recover <code>M = C^d mod n</code>.</li>
      </ol>

      <h2>Exercise premise: letter-by-letter RSA</h2>
      <p>Normally RSA encrypts properly prepared blocks. In this exercise we apply the RSA formula to every single letter (or its ASCII value). For example, we encrypt 'a' (ASCII 97), then 'b' (98), and so on.</p>
      <p>This effectively creates a homophonic substitution cipher: every 'a' will always map to the same number <code>(97^e % n)</code>, every 'b' to another fixed number, etc. Statistically, the frequency distribution is preserved, which is a serious flaw: the most frequent plaintext letter will correspond to the most frequent ciphertext number.</p>

      <h2>From statistics to cryptanalysis: breaking letter-by-letter RSA</h2>
      <p>Because frequency is preserved, we can attack the cipher. Given a ciphertext (a long list of numbers) we can:</p>
      <ol>
        <li>Count the frequency of each number in the ciphertext.</li>
        <li>Count the frequency of each letter in a reference text corpus (English or Italian).</li>
        <li>Create a decryption map: the most frequent ciphertext number likely corresponds to the most frequent letter in the reference text, the second to the second, and so on.</li>
      </ol>
      <p>The interactive simulation below implements exactly this attack: it encrypts letter-by-letter and then uses frequency analysis (rank + hill-climb) to recover the text without knowing <code>d</code>.</p>

    </article>

    <article class="card" id="demo">
      <h2>RSA Simulation and Frequency Attack</h2>

      <p class="small">This simulation encrypts text by applying the RSA formula to each symbol and then uses frequency analysis to infer the original text.</p>

      <ol>
        <li>Enter the original text (longer text works better):</li>
      </ol>

      <div style="display:flex;gap:12px;flex-wrap:wrap">
        <div style="flex:1"><label>Prime p</label><input id="p" type="number" value="61"></div>
        <div style="flex:1"><label>Prime q</label><input id="q" type="number" value="53"></div>
        <div style="flex:1"><label>Public exponent e</label><input id="e" type="number" value="17"></div>
      </div>

      <div class="controls" style="margin-top:10px">
        <button id="genKeys">Generate / verify keys</button>
        <div id="keyInfo" class="small">No key generated</div>
      </div>

      <label>Plaintext (A–Z and spaces)</label>
      <textarea id="plaintext">Statistics is the grammar of science. It allows us to understand the language of data, transforming uncertainty into knowledge and guiding our decisions with logic and rigor. Using statistical methods to analyze patterns is fundamental. In cryptography, frequency analysis is a classic example of how statistics can reveal hidden secrets in a ciphertext, especially in simple substitution ciphers like Caesar's. The 'e' and 'a' are very common in English.</textarea>

      <div class="controls">
        <label class="small">Mode
          <select id="mode"><option value="letters">letters</option><option value="ascii">ascii (short)</option></select>
        </label>

        <label class="small">Show as
          <select id="showAs"><option value="nums">numbers</option><option value="letters">letters (c mod 26)</option></select>
        </label>

        <button id="encryptBtn">Encrypt</button>
        <button id="decryptBtn">Decrypt with d</button>
      </div>

      <label>Ciphertext / output</label>
      <textarea id="cipherOut" readonly class="code"></textarea>

      <div class="controls" style="margin-top:8px">
        <button id="recoverFreq">Analyze frequencies + hill-climb</button>
        <button id="bruteBtn">Brute-force (capped)</button>
        <div class="small">Use small alphabets and texts to keep the demo responsive.</div>
      </div>

      <div class="chartRow" style="margin-top:12px">
        <div class="chartCard"><canvas id="chartPlain"></canvas><div class="small">Plaintext letter percentages</div></div>
        <div class="chartCard"><canvas id="chartCipher"></canvas><div class="small">Ciphertext percentages (c mod 26)</div></div>
      </div>

      <h3 style="margin-top:12px">Recovered candidates</h3>
      <table id="cands"><thead><tr><th>#</th><th>Method</th><th>Score</th><th>Plaintext</th></tr></thead><tbody></tbody></table>

      <pre id="diag" class="code">No run yet.</pre>
    </article>

    <article class="card">
      <h2>Suggested experiments</h2>
      <ul>
        <li>Measure recovery success probability as a function of plaintext length (law of large numbers for frequencies).</li>
        <li>Compare pure χ² ranking vs combined score (χ² + bigrams + wordScore).</li>
        <li>Test sensitivity to alphabet choice (Italian vs English) and to the mapping <code>c mod 26</code>.</li>
        <li>Observe how <code>c mod 26</code> mixes frequencies but does not fully hide them when <code>n</code> is small.</li>
      </ul>
    </article>

    <article class="card">
      <h2>References</h2>
      <ol>
        <li>R. L. Rivest, A. Shamir, L. Adleman, "A Method for Obtaining Digital Signatures and Public-Key Cryptosystems", 1978.</li>
        <li>A. Menezes, P. van Oorschot, S. Vanstone, "Handbook of Applied Cryptography".</li>
        <li>T. M. Cover, J. A. Thomas, "Elements of Information Theory".</li>
      </ol>
    </article>

    <article class="card">
      <h2>Correct RSA implementation in C (example)</h2>
      <p class="small">Example showing encryption/decryption on a number (practically a block), not per single letters.</p>
      <pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
typedef long long ll;

ll pow_mod(ll base, ll exp, ll mod) {
    ll res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % mod;
        base = (base * base) % mod;
        exp /= 2;
    }
    return res;
}

ll mod_inverse(ll a, ll m) {
    a = a % m;
    for (ll x = 1; x < m; x++) {
        if ((a * x) % m == 1) {
            return x;
        }
    }
    return 1;
}

int main(void) {
    ll p = 53;
    ll q = 59;
    ll e = 3;

    ll n = p * q;
    ll phi_n = (p - 1) * (q - 1);
    
    ll d = mod_inverse(e, phi_n);

    printf("--- RSA Parameters ---\n");
    printf("p = %lld, q = %lld, e = %lld\n", p, q, e);
    printf("Public Key (n, e): (%lld, %lld)\n", n, e);
    printf("Phi(n) = %lld\n", phi_n);
    printf("Private Key (d): %lld\n", d);
    
    ll message = 888;

    printf("\n--- Process ---\n");
    printf("Original Message (M): %lld\n", message);

    ll encrypted = pow_mod(message, e, n);
    printf("Encrypted (C): %lld\n", encrypted);

    ll decrypted = pow_mod(encrypted, d, n);
    printf("Decrypted (M'): %lld\n", decrypted);

    if (message == decrypted) {
        printf("\nSuccess: The message was recovered!\n");
    } else {
        printf("\nError: Decryption failed.\n");
    }
    
    return 0;
}

</code></pre>

      <p class="small">As shown, a correct RSA implementation operates on numbers/blocks and not on individual letters. Its security comes from the difficulty of obtaining <code>d</code> given only <code>n</code> and <code>e</code> (factoring <code>n</code> into <code>p</code> and <code>q</code>).</p>

      <p class="small">The vulnerability exploited in the simulation is not an intrinsic weakness of RSA, but an implementation weakness: applying a deterministic per-letter cipher (where 'a' always becomes the same symbol) creates a substitution cipher vulnerable to statistical analysis.</p>

    </article>

  </main>

  <footer class="small" style="margin-top:18px">© 2025 Riccardo D'Annibale</footer>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      if (window.MathJax && MathJax.typesetPromise) {
        MathJax.typesetPromise().catch(e => console.error('MathJax typeset error', e));
      }
    });
  </script>

  <script>
  function egcd(a,b){ if(b===0n) return [a,1n,0n]; const [g,x1,y1]=egcd(b,a%b); return [g,y1,x1-(a/b)*y1]; }
  function modInv(a,m){ const [g,x] = egcd(a,m); if(g !== 1n) throw new Error('No modular inverse'); return (x % m + m) % m; }
  function modPow(base,exp,mod){ base %= mod; let r = 1n; while(exp > 0n){ if((exp & 1n) === 1n) r = (r * base) % mod; base = (base * base) % mod; exp >>= 1n; } return r; }
  function isPrimeSmall(n){ if(n < 2n) return false; if(n % 2n === 0n) return n === 2n; for(let i=3n;i*i<=n;i+=2n) if(n % i === 0n) return false; return true; }

  const A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  function cleanLetters(s){ return String(s||'').toUpperCase().replace(/[^A-Z ]+/g,''); }
  function lettersToNums(s){ return Array.from(String(s||'')).map(ch => ch === ' ' ? 26 : A.indexOf(ch)); }
  function numsToLetters(arr){ return arr.map(n => n === 26 ? ' ' : (A[n]||'?')).join(''); }

  const refFreq = {'A':10.85,'B':1.05,'C':4.30,'D':3.39,'E':11.49,'F':1.01,'G':1.65,'H':1.43,'I':10.18,'J':0.01,'K':0.01,'L':5.70,'M':2.87,'N':7.02,'O':9.97,'P':2.96,'Q':0.45,'R':6.19,'S':5.48,'T':6.97,'U':3.16,'V':1.75,'W':0.01,'X':0.01,'Y':0.06,'Z':0.85,' ':11.0};
  const commonWords = new Set(['the','and','is','in','to','of','that','it','on','for','with','as','are','this','be','by','was','or','from','di','e','il','la','che']);

  function wordScore(s){ const tokens = String(s||'').toLowerCase().split(/[^a-z]+/).filter(Boolean); if(!tokens.length) return 0; let hits=0; for(const t of tokens) if(commonWords.has(t)) hits++; return hits/tokens.length; }

  let chartPlain=null, chartCipher=null;
  function initCharts(){
    const labels = A.split('').concat(['SPACE']);
    const empty = labels.map(()=>0);
    const opts = { type:'bar', data:{ labels, datasets:[{ label:'%', data: empty }] }, options:{ responsive:false, animation:false, scales:{ y:{ beginAtZero:true } } } };
    chartPlain = new Chart(document.getElementById('chartPlain').getContext('2d'), JSON.parse(JSON.stringify(opts)));
    chartCipher = new Chart(document.getElementById('chartCipher').getContext('2d'), JSON.parse(JSON.stringify(opts)));
  }
  initCharts();

  function updateCharts(plain, cipherSymbols){
    const cntP = Array(27).fill(0); for(const ch of String(plain||'')){ if(ch === ' ') cntP[26]++; else{ const i = A.indexOf(ch); if(i >= 0) cntP[i]++; } }
    const totP = cntP.reduce((a,b)=>a+b,0)||1; chartPlain.data.datasets[0].data = cntP.map(c => c/totP*100); chartPlain.update();

    const cntC = Array(27).fill(0);
    for(const s of (cipherSymbols||[])){
      try{
        const v = Number(BigInt(s) % 26n);
        if(Number.isFinite(v)) cntC[v]++;
      }catch(e){}
    }
    const totC = cntC.reduce((a,b)=>a+b,0)||1; chartCipher.data.datasets[0].data = cntC.map(c => c/totC*100); chartCipher.update();
  }

  const $ = id => document.getElementById(id);
  let state = { p:null,q:null,n:null,e:null,d:null,lastCipherNums:[],lastCipherMap:[] };

  $('genKeys').addEventListener('click', ()=>{
    try{
      const p = BigInt(Number($('p').value)), q = BigInt(Number($('q').value)), e = BigInt(Number($('e').value));
      if(p <= 1n || q <= 1n) throw new Error('p/q invalid');
      if(p === q) throw new Error('p and q must differ');
      const n = p * q; const phi = (p - 1n) * (q - 1n);
      let d = null; try{ d = modInv(e, phi); } catch(err){ d = null; }
      state = { p, q, n, e, d, phi };
      $('keyInfo').textContent = (isPrimeSmall(p) && isPrimeSmall(q) ? 'p,q appear prime. ' : 'Warning: p/q may not be prime. ') + 'n=' + String(n) + (d ? (' d=' + String(d)) : ' (d not calculated)');
      $('diag').textContent = 'Keys: n=' + String(n) + ' φ(n)=' + String(phi) + ' e=' + String(e) + ' d=' + (d ? String(d) : '---');
    } catch(err){ $('keyInfo').textContent = 'Error: ' + err.message; $('diag').textContent = 'Error: ' + err.message; }
  });

  $('encryptBtn').addEventListener('click', ()=>{
    try{
      if(!state.p){ $('diag').textContent = 'Generate keys first'; return; }
      const mode = $('mode').value; const text = String($('plaintext').value || '');
      if(mode === 'ascii'){
        const bytes = new TextEncoder().encode(text);
        const m = bytes.reduce((acc,b)=> (acc<<8n) + BigInt(b), 0n);
        if(m >= state.n){ $('diag').textContent = 'ERROR: integer >= n'; return; }
        const c = modPow(m, state.e, state.n);
        $('cipherOut').value = String(c); $('diag').textContent = 'ASCII: m=' + String(m) + ' c=' + String(c); return;
      }
      const cleaned = cleanLetters(text);
      const nums = lettersToNums(cleaned);
      if(!nums.length){ $('cipherOut').value = ''; $('diag').textContent = 'Empty plaintext'; return; }
      const cipherNums = nums.map(m => modPow(BigInt(m), state.e, state.n));

      state.lastCipherNums = cipherNums.map(x => String(x));
      state.lastCipherMap = cipherNums.map(x => String(x));

      $('cipherOut').value = $('showAs').value === 'nums' ? state.lastCipherNums.join(' ') : state.lastCipherNums.map(x => {
        try{ return A[Number(BigInt(x) % 26n)]; }catch(e){ return '?'; }
      }).join('');

      $('diag').textContent = 'Encrypted numbers: [' + state.lastCipherNums.join(',') + ']';
      updateCharts(cleaned, state.lastCipherMap);
    } catch(err){ $('diag').textContent = 'Encrypt error: ' + String(err); }
  });

  $('decryptBtn').addEventListener('click', ()=>{
    try{
      if(!state.d){ $('diag').textContent = 'd not available (generate valid keys)'; return; }
      if(!state.lastCipherNums.length){ $('diag').textContent = 'No ciphertext'; return; }
      const dec = state.lastCipherNums.map(c => Number(modPow(BigInt(c), state.d, state.n)));
      const plain = numsToLetters(dec);
      $('cipherOut').value = plain; $('diag').textContent = 'Decrypted (with d): ' + plain;
      updateCharts(cleanLetters(plain), state.lastCipherMap || []);
    } catch(err){ $('diag').textContent = 'Decrypt error: ' + String(err); }
  });

  $('recoverFreq').addEventListener('click', ()=>{
    try{
      if(!state.lastCipherMap.length){ $('diag').textContent = 'No ciphertext mapped'; return; }

      const countsObj = Object.create(null);
      for(const v of state.lastCipherMap){ countsObj[v] = (countsObj[v] || 0) + 1; }
      const symbols = Object.keys(countsObj);
      const orderCipher = symbols.slice().sort((a,b)=> countsObj[b]-countsObj[a] || a.localeCompare(b));

      const refOrder = Object.keys(refFreq).slice().sort((a,b)=> refFreq[b]-refFreq[a]);

      const symbolIndexMap = Object.create(null);
      orderCipher.forEach((s,i)=> symbolIndexMap[s]=i);

      const curMap = Array(orderCipher.length).fill(null);
      for(let i=0;i<orderCipher.length && i<refOrder.length;i++){
        const target = refOrder[i];
        curMap[i] = (target === ' ') ? 26 : (target.charCodeAt(0)-65);
      }

      function applyMapArray(mapArr){
        return state.lastCipherMap.map(sym => {
          const idx = symbolIndexMap[sym];
          const val = (typeof idx === 'number') ? mapArr[idx] : null;
          if(val === null || typeof val === 'undefined') return '?';
          return (val === 26) ? ' ' : (A[val] || '?');
        }).join('');
      }

      function scoreCandidate(s){
        const ws = wordScore(s);
        const cnts = Array(27).fill(0); for(const ch of s){ if(ch===' ') cnts[26]++; else{ const idx=A.indexOf(ch); if(idx>=0) cnts[idx]++; } }
        const tot = cnts.reduce((a,b)=>a+b,0)||1;
        let chi2=0; for(let i=0;i<27;i++){
          let L = (i===26) ? ' ' : A[i];
          const obs = cnts[i]/tot*100;
          const exp = refFreq[L] || 0.01;
          chi2 += ((obs-exp)*(obs-exp))/exp;
        }
        return {final: ws*10 - chi2*0.01, ws, chi2};
      }

      let best = { plain: applyMapArray(curMap), map: curMap.slice(), score: scoreCandidate(applyMapArray(curMap)) };
      let improved=true, iter=0, maxIter=5000;

      while(improved && iter<maxIter){ improved=false; iter++;
        outer: for(let i=0;i<curMap.length;i++){
          for(let j=i+1;j<curMap.length;j++){
            const tmp = curMap.slice(); const ti=tmp[i], tj=tmp[j]; tmp[i]=tj; tmp[j]=ti;
            const candPlain = applyMapArray(tmp);
            const sc = scoreCandidate(candPlain).final;
            if(sc > best.score.final + 1e-9){ best = { plain:candPlain, map:tmp.slice(), score: scoreCandidate(candPlain) }; curMap.splice(0, curMap.length, ...tmp); improved=true; break outer; }
          }
        }
      }

      const tbody = document.querySelector('#cands tbody'); tbody.innerHTML='';
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>1</td><td>freq+hill</td><td>${best.score.final.toFixed(4)} (ws=${best.score.ws.toFixed(3)} chi2=${best.score.chi2.toFixed(2)})</td><td><code>${escapeHtml(best.plain)}</code></td>`;
      tbody.appendChild(tr);
      $('diag').textContent = 'Recovery completed in ' + iter + ' iterations';
      $('cipherOut').value = best.plain; updateCharts(cleanLetters(best.plain), state.lastCipherMap||[]);
    } catch(err){ $('diag').textContent = 'Recover error: ' + String(err); }
  });

  $('bruteBtn').addEventListener('click', ()=>{
    try{
      if(!state.lastCipherNums.length){ $('diag').textContent = 'No ciphertext'; return; }
      const target = state.lastCipherNums.join('|');
      const maxLen=3, cap=200000; let tested=0, found=null;
      function* gen(len){ const idx=Array(len).fill(0); while(true){ yield idx.map(i=>A[idx[i]]).join(''); let pos=len-1; while(pos>=0){ idx[pos]++; if(idx[pos]<26) break; idx[pos]=0; pos--; } if(pos<0) return; } }
      for(let L=1; L<=maxLen && !found; L++){
        for(const s of gen(L)){
          tested++; if(tested>cap){ $('diag').textContent='Cap exceeded '+tested; break; }
          const nums = lettersToNums(s);
          const cnums = nums.map(m => String(modPow(BigInt(m), state.e, state.n)));
          if(cnums.join('|') === target){ found=s; break; }
        }
      }
      $('diag').textContent = found ? 'Brute found: '+found : 'Brute finished, tested '+tested;
      if(found) document.querySelector('#cands tbody').innerHTML = `<tr><td>BF</td><td>brute</td><td>-</td><td><code>${escapeHtml(found)}</code></td></tr>`;
    } catch(err){ $('diag').textContent = 'Brute error: ' + String(err); }
  });

  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  </script>
</body>
</html>
