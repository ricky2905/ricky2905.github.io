<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Bernoulli process, LLN, CLT, Pascal & Fibonacci</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="University essay and interactive tools: Bernoulli process, LLN, CLT, Pascal's triangle, binomial expansion, Fibonacci.">
  <style>
    :root{ --bg:#0f111a; --panel:#1a1c2b; --accent:#4CAF50; --muted:#cfd8cf; --text:#e0e0e0 }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", Roboto, Arial, sans-serif;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
    .wrap{max-width:1100px;margin:2rem auto;padding:2rem}
    .topnav{display:flex;gap:1rem;margin-bottom:1rem}
    .topnav a{color:var(--accent);text-decoration:none;font-weight:700}
    /* make all headings green */
    h1,h2,h3,h4,h5,h6{ color:var(--accent); }
    h1{font-size:2.2rem;border-bottom:3px solid var(--accent);padding-bottom:.3rem}
    .card{background:var(--panel);border-left:5px solid var(--accent);border-radius:8px;padding:1.25rem;margin:1.25rem 0;box-shadow:0 6px 24px rgba(76,175,80,0.06)}
    .small{font-size:13px;color:var(--muted)}
    label{display:block;margin-top:10px;font-weight:700;color:var(--accent)}
    input, select{width:100%;padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:#0b0c10;color:var(--text)}
    .controls{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap}
    .code{background:#0b0c10;padding:12px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);color:#dfeee0;overflow:auto}
    .chartRow{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
    .chartCard{flex:1 1 360px;background:#0f111a;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:260px;height:360px;box-sizing:border-box;overflow:hidden}
    .chartCard canvas{width:100%;height:200px;display:block}
    pre{background:#0b0c10;color:#dfeee0;padding:12px;border-radius:6px;overflow-x:auto;border:1px solid rgba(255,255,255,0.03)}
    button{padding:8px 12px;border-radius:6px;background:var(--accent);border:0;color:#072;font-weight:700;cursor:pointer}
    .display-equation{background:rgba(255,255,255,0.02);padding:10px 12px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);margin:12px 0}
    .pascalRow{font-family:monospace;white-space:pre}
    .explain { margin-top:10px; line-height:1.5 }
    .metrics { margin-top:8px; font-size:13px; color:var(--muted) }
    .formal { margin-top:10px; padding:10px; background:rgba(255,255,255,0.015); border-radius:6px; border:1px solid rgba(255,255,255,0.02) }
    /* MathJax SVG styling for clarity */
    .mjx-svg { fill: var(--text) !important; display:block; margin:.4rem 0; shape-rendering:geometricPrecision; }
    .mjx-svg .mjx-mrow { font-size:1.18rem !important; }
    @media(max-width:520px){ .mjx-svg .mjx-mrow { font-size:1.0rem !important } }
  </style>

  <!-- MathJax (SVG output, scale tuned for legibility) -->
  <script>
    window.MathJax = {
      loader: { load: ['input/tex','output/svg'] },
      tex: {
        inlineMath: [['\\(','\\)'], ['$', '$']],
        displayMath: [['\\[','\\]']],
        packages: {'[+]': ['ams']}
      },
      options: { skipHtmlTags: ['script','style','textarea','pre','code'] },
      svg: { fontCache: 'none', scale: 1.35 }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" defer></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4" defer></script>
</head>
<body>
  <div class="wrap">
     <header class="topnav" role="navigation" aria-label="Main navigation">
      <a href="/" aria-label="Home">Home</a>
      <a href="/about/" aria-label="About">About</a>
      <div style="flex:1"></div>
    </header>

    <main>
      <article class="card">
        <h1>HMWK 2 — Processo di Bernoulli, LLN, CLT e connessioni combinatorie</h1>
      </article>

      <article class="card">
        <h2>1. Processo di Bernoulli e binomiale</h2>
        <div class="display-equation">
          \[
            X_1,X_2,\dots \overset{\text{iid}}{\sim} \mathrm{Bernoulli}(p),\qquad
            S_n=\sum_{i=1}^{n} X_i\sim\mathrm{Binom}(n,p).
          \]
        </div>
        <div class="display-equation">
          \[
            \mathbb{E}[S_n]=np,\qquad \mathrm{Var}(S_n)=np(1-p).
          \]
        </div>
      </article>

      <article class="card">
        <h2>2. Legge dei grandi numeri (LLN)</h2>
        <div class="display-equation">
          \[
            \overline{X}_n=\frac{S_n}{n}=\frac{1}{n}\sum_{i=1}^n X_i \xrightarrow{a.s.} \mathbb{E}[X_1]=p.
          \]
        </div>
        <p class="formal">Enunciato (forte): per \(X_i\) iid con \(\mathbb{E}[|X_1|]<\infty\),
          \(\frac{1}{n}\sum_{i=1}^n X_i \xrightarrow{a.s.} \mathbb{E}[X_1]\).
          Nel caso Bernoulli la convergenza implica che, per quasi ogni realizzazione, la media campionaria converge a \(p\) al crescere di \(n\).</p>
      </article>

      <article class="card">
        <h2>3. Teorema del limite centrale (CLT)</h2>
        <div class="display-equation">
          \[
            \sqrt{n}\,(\overline{X}_n - p) \xrightarrow{d} \mathcal{N}\big(0,\;p(1-p)\big).
          \]
        </div>
        <p class="formal">CLT: per \(X_i\) iid con media \(\mu\) e varianza \(\sigma^2\),
          \(\sqrt{n}(\overline X_n - \mu)\xrightarrow{d} N(0,\sigma^2)\). Nel caso Bernoulli \(\mu=p\), \(\sigma^2=p(1-p)\).</p>
      </article>

      <article class="card">
        <h2>4. Triangolo di Pascal, espansione binomiale e Fibonacci</h2>
        <div class="display-equation">
          \[
            \binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k},\qquad
            (a+b)^n=\sum_{k=0}^n\binom{n}{k}a^{n-k}b^k.
          \]
        </div>
        <div class="display-equation">
          \[
            F_n=\sum_{i=0}^{\lfloor (n-1)/2\rfloor} \binom{n-1-i}{i}.
          \]
        </div>
        <p class="explain">L'identità per Fibonacci mostra come sommando opportune diagonali del triangolo di Pascal si ottengano i termini della successione di Fibonacci. L'espansione binomiale collega invece i coefficienti combinatori alle probabilità nel modello Bernoulli ponendo \(a=1-p\), \(b=p\).</p>
      </article>

      <article class="card">
        <h2>5. Demo interattive: LLN, Binomiale e CLT</h2>
        <div class="controls">
          <div style="flex:1"><label>n (prove)</label><input id="n_lln" type="number" value="500" min="2" max="200000"></div>
          <div style="flex:1"><label>m (percorsi LLN)</label><input id="m_lln" type="number" value="50" min="1" max="500"></div>
          <div style="flex:1"><label>p (Bernoulli)</label><input id="p_lln" type="number" step="0.01" value="0.6" min="0" max="1"></div>
        </div>
        <div class="controls" style="margin-top:8px">
          <button id="btn_lln" class="btn">Esegui LLN & Binom</button>
          <button id="btn_clt" class="btn" style="background:#66bb6a">Mostra CLT (istogramma)</button>
        </div>

        <div class="chartRow" style="margin-top:12px" role="region" aria-label="Grafici interattivi">
          <div class="chartCard" aria-label="Grafico LLN">
            <canvas id="llnChart" role="img" aria-label="Evoluzione delle medie campionarie"></canvas>
            <div class="small">Curva: medie campionarie \(\overline X_k\) per diversi percorsi. Linea tratteggiata = valore teorico \(p\).</div>
            <div id="lln_metrics" class="metrics" aria-live="polite"></div>
          </div>

          <div class="chartCard" aria-label="Grafico binomiale">
            <canvas id="binomChart" role="img" aria-label="Distribuzione empirica vs binomiale teorica"></canvas>
            <div class="small">Barre: frequenze empiriche di \(S_n\). Linea: probabilità teorica \(\mathrm{Binom}(n,p)\).</div>
            <div id="binom_metrics" class="metrics" aria-live="polite"></div>
          </div>

          <div class="chartCard" aria-label="Grafico CLT">
            <canvas id="cltChart" role="img" aria-label="Istogramma della quantità standardizzata e densità normale"></canvas>
            <div class="small">Istogramma di \(\sqrt{n}(\overline X_n - p)\) con sovrapposta la densità teorica \(\mathcal{N}(0,p(1-p))\).</div>
            <div id="clt_metrics" class="metrics" aria-live="polite"></div>
          </div>
        </div>
      </article>

      <article class="card">
        <h2>6. Confronto formale e analogie con il compito precedente</h2>

        <div class="formal">
          <h3 style="margin:0 0 .5rem 0; color:var(--accent)">Obiettivo</h3>
          <p>Questo paragrafo mette in relazione l'esercizio corrente con il compito precedente (dove il parametro efficace per prova era \(q=(1-p_{\text{attacker}})^m\)). Si evidenziano analogie, differenze e i richiami combinatori rilevanti.</p>

          <h4 style="margin-top:0.6rem">1. Perspektiva generale: pathwise vs ensemble</h4>
          <p>
            In entrambi i compiti l'unità fondamentale è la prova di Bernoulli con probabilità di successo fissata (nel compito precedente \(q\), qui \(p\)). Due prospettive complementari:
          </p>
          <ul>
            <li><strong>Pathwise (LLN):</strong> si segue una singola realizzazione e si osserva la media campionaria \(\overline X_k\). Il risultato di LLN assicura che, per quasi ogni percorso, \(\overline X_n\to p\) (o \(\to q\)).</li>
            <li><strong>Ensemble (Binomiale):</strong> si ripete l'intero esperimento di lunghezza fissa \(n\) molte volte e si costruisce la distribuzione empirica di \(S_n\). Questa distribuzione è governata dal PMF binomiale
              \[
                P(S_n=k)=\binom{n}{k}p^k(1-p)^{n-k},
              \]
              con \(p\) sostituito da \(q\) nel compito precedente.</li>
          </ul>

          <h4 style="margin-top:0.6rem">2. Sostituzione \(p \mapsto q\)</h4>
          <p class="formal">
            Tutte le formule e i teoremi si trasferiscono sostituendo \(p\) con \(q=(1-p_{\text{attacker}})^m\). In particolare:
            \[
              S_n\sim\mathrm{Binom}(n,q),\quad \mathbb{E}[S_n]=nq,\quad \mathrm{Var}(S_n)=nq(1-q),
            \]
            e
            \[
              \overline X_n \xrightarrow{a.s.} q,\qquad \sqrt{n}(\overline X_n - q)\xrightarrow{d}\mathcal{N}(0,q(1-q)).
            \]
            Questo mostra che la differenza fra i due compiti è prevalentemente numerica (valore della probabilità) e non strutturale.
          </p>

          <h4 style="margin-top:0.6rem">3. Relazioni combinatorie e ruolo di Pascal</h4>
          <p>
            La relazione ricorsiva dei coefficienti binomiali
            \[
              \binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}
            \]
            costruisce il triangolo di Pascal; l'espansione binomiale
            \[
              (1-p + p)^n = \sum_{k=0}^n \binom{n}{k}(1-p)^{n-k} p^k = 1
            \]
            collega direttamente i coefficienti combinatori alla probabilità degli eventi binomiali. Le somme su diagonali di Pascal producono, fra l'altro, la successione di Fibonacci:
            \[
              F_n=\sum_{i=0}^{\lfloor (n-1)/2\rfloor} \binom{n-1-i}{i}.
            \]
            Inserire un pannello grafico (Pascal con diagonali evidenziate) è utile in relazione alla parte combinatoria dell'esame.
          </p>

          <h4 style="margin-top:0.6rem">4. Interpretazione pratica e suggerimenti per la relazione</h4>
          <ol>
            <li>Includere le figure: (A) percorsi di \(\overline X_k\) con linea tratteggiata \(p\) (o \(q\)); (B) bar chart della distribuzione empirica di \(S_n\) con sovrapposta la curva teorica \(\mathrm{Binom}(n,p)\) (o \(\mathrm{Binom}(n,q)\)); (C) istogramma di \(\sqrt{n}(\overline X_n-p)\) con densità normale teorica; (D) triangolo di Pascal annotato per la Fibonacci.</li>
            <li>Riportare sempre i parametri sperimentali: \(n\), \(p\) (o \(q\)), numero di percorsi \(m\), numero di ripetizioni \(R\) per la stima empirica, e numero di bin per gli istogrammi.</li>
            <li>Discutere discrepanze a campione finito: errore Monte Carlo, skewness per \(p\) lontano da 0.5, accuratezza dell'approssimazione normale al crescere di \(n\) (velocità \(O(1/\sqrt{n})\)).</li>
            <li>Nel testo esplicitare la sostituzione \(p\mapsto q\) quando si paragona al compito precedente e commentare i risultati numerici in questo contesto.</li>
          </ol>

          <p class="formal"><strong>Conclusione.</strong> L'esercizio corrente è direttamente riconducibile al precedente tramite la sostituzione della probabilità di successo; le connessioni combinatorie (coefficienti binomiali, Pascal, espansione binomiale e Fibonacci) forniscono un quadro matematico coerente che giustifica le osservazioni empiriche fornite dalle demo.</p>
        </div>
      </article>

      <article class="card">
        <h2>7. Triangolo di Pascal e Fibonacci (tool)</h2>
        <div class="controls" style="margin-top:8px">
          <div style="flex:1"><label>Genera Pascal fino a riga n</label><input id="pascal_n" type="number" value="12" min="1" max="30"></div>
          <button id="gen_pascal" class="btn">Genera Pascal</button>
        </div>
        <div id="pascal_box" class="code" style="margin-top:8px;max-height:220px;overflow:auto"></div>
        <pre id="fib_out" class="code">—</pre>
      </article>

      <article class="card">
        <h2>Riferimenti</h2>
        <ol class="small"><li>W. Feller, <em>An Introduction to Probability Theory and Its Applications</em>, Vol.1.</li><li>P. Billingsley, <em>Probability and Measure</em>.</li><li>G. Graham, D. Knuth, O. Patashnik, <em>Concrete Mathematics</em>.</li></ol>
      </article>
    </main>

    <footer class="small">© 2025 Riccardo D'Annibale</footer>
  </div>

  <script>
    // Wait for Chart.js
    function ready(){
      if(typeof Chart === 'undefined'){ setTimeout(ready,50); return; }

      // combinatorics helper
      function binomCoeff(n,k){
        if(k<0||k>n) return 0;
        k = Math.min(k, n-k);
        let num=1, den=1;
        for(let i=1;i<=k;i++){ num *= (n - (k - i)); den *= i; }
        return Math.round(num/den);
      }

      function generatePascal(n){
        const T = [];
        for(let i=0;i<=n;i++){
          T[i]=[];
          for(let j=0;j<=i;j++){
            if(j===0||j===i) T[i][j]=1; else T[i][j]=T[i-1][j-1]+T[i-1][j];
          }
        }
        return T;
      }

      // UI: Pascal
      document.getElementById('gen_pascal').addEventListener('click', ()=>{
        const n = Math.max(1, Math.min(30, Math.floor(Number(document.getElementById('pascal_n').value))));
        const T = generatePascal(n);
        const box = document.getElementById('pascal_box'); box.innerHTML='';
        const maxLen = T[n].length * 4;
        for(let i=0;i<T.length;i++){
          const row = T[i].map(x=>String(x).padStart(3,' ')).join(' ');
          const pad = ' '.repeat(Math.floor((maxLen - row.length)/2));
          const div = document.createElement('div'); div.className='pascalRow'; div.textContent = pad + row;
          box.appendChild(div);
        }
        const fib = [1,1];
        for(let k=3;k<=n+2;k++){
          let s=0;
          for(let i=0;i<=Math.floor((k-1)/2);i++){ s += binomCoeff(k-1-i, i); }
          fib.push(s);
        }
        document.getElementById('fib_out').textContent = 'Fibonacci (estratto dalle diagonali di Pascal):\n' + fib.join(', ');
      });

      // Charts setup
      const llnCtx = document.getElementById('llnChart').getContext('2d');
      const binomCtx = document.getElementById('binomChart').getContext('2d');
      const cltCtx = document.getElementById('cltChart').getContext('2d');

      let llnChart = new Chart(llnCtx, {
        type:'line',
        data:{ labels:[], datasets:[] },
        options:{
          responsive:true,
          plugins:{ legend:{ display:true } },
          scales:{ y:{ min:0, max:1, title:{display:true, text:'media campionaria' } }, x:{ title:{display:true, text:'k (numero di prove)' } } }
        }
      });

      let binomChart = new Chart(binomCtx, {
        type:'bar',
        data:{ labels:[], datasets:[] },
        options:{
          responsive:true,
          plugins:{ legend:{ display:true } },
          scales:{ y:{ beginAtZero:true, title:{display:true, text:'probabilità / frequenza' } }, x:{ title:{display:true, text:'conteggio k' } } }
        }
      });

      let cltChart = new Chart(cltCtx, {
        type:'bar',
        data:{ labels:[], datasets:[] },
        options:{
          responsive:true,
          plugins:{ legend:{ display:true } },
          scales:{ y:{ beginAtZero:true, title:{display:true, text:'densità/frequenza normalizzata' } }, x:{ title:{display:true, text:'valore standardizzato' } } }
        }
      });

      // helper: normal pdf
      function normalPdf(x, mu, sigma){
        return (1/(Math.sqrt(2*Math.PI)*sigma)) * Math.exp(-0.5 * Math.pow((x-mu)/sigma,2));
      }

      // helper: histogram bins
      function histogram(data, binCount){
        const min = Math.min(...data);
        const max = Math.max(...data);
        const eps = (max - min) * 1e-6;
        const width = (max - min + eps)/binCount;
        const bins = Array(binCount).fill(0);
        const edges = [];
        for(let i=0;i<binCount;i++) edges.push(min + i*width);
        for(const v of data){
          let idx = Math.floor((v - min)/width);
          if(idx<0) idx=0;
          if(idx>=binCount) idx=binCount-1;
          bins[idx]++;
        }
        const centers = edges.map((e,i)=> e + width/2);
        const freqs = bins.map(b => b / data.length); // relative frequency
        return {centers, freqs, width};
      }

      // LLN + Binomial button
      document.getElementById('btn_lln').addEventListener('click', ()=>{
        const n = Math.max(1, Math.floor(Number(document.getElementById('n_lln').value)));
        const m = Math.max(1, Math.floor(Number(document.getElementById('m_lln').value)));
        const p = Math.max(0, Math.min(1, Number(document.getElementById('p_lln').value)));

        // LLN: sample points (limit to 200 for performance)
        const samplePoints = 200;
        const step = Math.max(1, Math.floor(n / samplePoints));
        const labels = []; for(let i=step;i<=n;i+=step) labels.push(i);

        const datasets = [];
        for(let path=0; path<m; path++){
          let sum = 0; const data=[];
          for(let i=1;i<=n;i++){
            const X = Math.random() < p ? 1 : 0; sum += X;
            if(i % step === 0) data.push(sum / i);
          }
          datasets.push({ label: 'percorso '+(path+1), data, borderColor:'rgba(255,255,255,0.12)', pointRadius:0, tension:0.3, fill:false, borderWidth:1 });
        }
        // add theoretical p
        const pLine = Array(labels.length).fill(p);
        datasets.push({ label: 'p (valore atteso)', data: pLine, borderColor: 'rgba(76,175,80,0.95)', borderWidth:2, pointRadius:0, tension:0, borderDash:[6,6], fill:false });

        llnChart.data.labels = labels; llnChart.data.datasets = datasets; llnChart.update();

        // Binomial empirical vs theoretical
        const trials = 2000;
        const counts = Array(n+1).fill(0);
        for(let t=0;t<trials;t++){
          let k=0;
          for(let i=0;i<n;i++) if(Math.random() < p) k++;
          counts[k]++;
        }
        const freqs = counts.map(c=>c/trials);
        const theo = counts.map((_,k) => binomCoeff(n,k) * Math.pow(p,k) * Math.pow(1-p,n-k));
        const labelsK = counts.map((_,k)=>k);

        binomChart.data.labels = labelsK;
        binomChart.data.datasets = [
          { label:'Empirico (frequenza)', data: freqs, backgroundColor:'rgba(76,175,80,0.45)' },
          { label:'Teorico Binom(n,p)', data: theo, type:'line', borderColor:'#ffffff', borderWidth:2, fill:false, pointRadius:2, tension:0.2 }
        ];
        binomChart.update();

        // metrics text
        const mean_count = n * p;
        const var_count = n * p * (1 - p);
        const var_bar = (p * (1 - p)) / n;

        document.getElementById('binom_metrics').textContent =
          `Media teorica S_n = np = ${mean_count.toFixed(3)} · Var(S_n) = np(1-p) = ${var_count.toFixed(3)}. (n=${n}, p=${p})`;

        document.getElementById('lln_metrics').textContent =
          `Media teorica della media campionaria = p = ${p.toFixed(3)} · Var(\\overline{X}_n) = p(1-p)/n = ${var_bar.toFixed(6)}.`;
      });

      // CLT demo button: histogram of sqrt(n)(Xbar - p)
      document.getElementById('btn_clt').addEventListener('click', ()=>{
        const n = Math.max(2, Math.floor(Number(document.getElementById('n_lln').value)));
        const p = Math.max(0, Math.min(1, Number(document.getElementById('p_lln').value)));
        const repetitions = 5000;

        const zvals = [];
        for(let t=0;t<repetitions;t++){
          let k=0;
          for(let i=0;i<n;i++) if(Math.random() < p) k++;
          const xbar = k / n;
          zvals.push(Math.sqrt(n) * (xbar - p));
        }

        // histogram
        const bins = Math.min(50, Math.max(10, Math.round(Math.sqrt(repetitions))));
        const hist = histogram(zvals, bins);
        // theoretical normal density N(0, sigma^2) with sigma^2 = p(1-p)
        const sigma = Math.sqrt(p * (1 - p));
        // create density points on same centers
        const dens = hist.centers.map(x => normalPdf(x, 0, sigma));
        // Scale density to match histogram relative frequency (density * binWidth ≈ prob)
        const densityScaled = dens.map(d => d * hist.width);

        cltChart.data.labels = hist.centers.map(c => c.toFixed(3));
        cltChart.data.datasets = [
          { label: `Istogramma (repetitions=${repetitions})`, data: hist.freqs, backgroundColor:'rgba(120,144,156,0.45)' },
          { label: `Densità teorica N(0,${(p*(1-p)).toFixed(5)})`, data: densityScaled, type:'line', borderColor:'#ffffff', borderWidth:2, fill:false, pointRadius:0, tension:0.3 }
        ];
        cltChart.update();

        // metrics
        const sampleMean = zvals.reduce((a,b)=>a+b,0)/zvals.length;
        const sampleVar = zvals.reduce((a,b)=>a + (b - sampleMean)*(b - sampleMean),0) / (zvals.length-1);
        document.getElementById('clt_metrics').textContent =
          `E[z] ≈ ${sampleMean.toFixed(4)} · Var[z] ≈ ${sampleVar.toFixed(4)} · var teorica = p(1-p) = ${(p*(1-p)).toFixed(4)}. (n=${n}, p=${p})`;
      });

    } // ready
    ready();
  </script>
</body>
</html>
