<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mean & Variance Simulator — Online Algorithms (Welford)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f111a;
      --panel:#141622;
      --accent:#4CAF50;
      --muted:#9fb89f;
      --glass: rgba(255,255,255,0.03);
      --card-border: rgba(76,175,80,0.08);
      --text:#e6f4e6;
      --mono:#dfeee0;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background-color: var(--bg);
      color: var(--text);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      padding: 2rem;
      max-width: 1100px;
      margin-left: auto;
      margin-right: auto;
    }

    .wrap { width:100%; padding: 0; }
    .topnav { display:flex; gap:0.75rem; margin-bottom:1rem; align-items:center; flex-wrap:wrap; }
    .topnav a { color: var(--accent); text-decoration: none; font-weight: 700; }
    .topnav a:hover { color: #66bb6a; }
    h1,h2,h3 { color: var(--accent); margin: 0; }
    h1 { font-size: 1.9rem; border-bottom: 3px solid var(--accent); padding-bottom: 0.3rem; margin-bottom: 0.75rem; }
    .card { background-color: var(--panel); border-left: 5px solid var(--accent); border-radius: 10px; padding: 1.25rem; margin: 1rem 0; box-shadow: 0 8px 30px rgba(0,0,0,0.5); border: 1px solid var(--card-border); }
    .small { font-size: 13px; color: var(--muted); }
    label { display:block; margin-top:10px; font-weight:700; color:var(--text); }
    input, textarea, select, button.secondary {
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      background:#0b0c10; color:var(--text); font-size:14px;
    }
    textarea { resize: vertical; }
    .controls { display:flex; gap:12px; margin-top:12px; flex-wrap:wrap; }
    .controls > * { flex: 1 1 auto; min-width:140px; }
    .btn {
      padding:10px 14px; border-radius:8px; background:var(--accent); border:0; color:#072; font-weight:800; cursor:pointer;
      box-shadow: 0 6px 18px rgba(76,175,80,0.07);
    }
    .btn.ghost { background: transparent; color: var(--muted); border:1px solid rgba(255,255,255,0.04); font-weight:700; box-shadow:none; }
    .muted { color: var(--muted); }

    .layout { display:grid; grid-template-columns: 1fr 360px; gap:16px; align-items:start; }
    @media(max-width:980px){ .layout{ grid-template-columns:1fr } }

    .chart {
      background:#0b0c10;
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      min-height:260px;
      max-height:260px;
      height:260px;
      box-sizing:border-box;
      overflow:auto;
    }
    .chart canvas { display:block; width:100% !important; height:100% !important; }
    .values-list { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; color:var(--mono); background: rgba(255,255,255,0.02); padding:8px; border-radius:6px; margin-top:8px; white-space:pre-wrap; word-break:break-word; }
    .code { background:#0b0c10; padding:12px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); color:var(--mono); overflow:auto; }
    .display-equation { background: rgba(255,255,255,0.02); padding:10px 12px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); margin:8px 0; font-size:1rem; color:var(--mono); }
    footer { opacity:0.8; font-size:13px; margin-top:18px; text-align:center; }
    table { width:100%; border-collapse:collapse; }
    th, td { padding:6px 8px; text-align:left; border-bottom:1px solid rgba(255,255,255,0.03); color:var(--mono); font-size:0.95rem; }
  </style>

  <!-- MathJax for equations -->
  <script>
    window.MathJax = {
      loader: { load: ['input/tex','output/chtml'] },
      tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
      chtml: { scale: 1 }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
</head>
<body>
  <div class="wrap">
    <header class="topnav">
      <a href="/" aria-label="Home">Home</a>
      <a href="/about/" aria-label="About">About</a>
    </header>

    <main>

      <article class="card" aria-labelledby="explain-title">
        <h1 id="explain-title">Mean and Variance Simulator - Numerical Stability and Algorithm Comparison</h1>

        <h3>1) Mean recurrence (simple proof)</h3>
        <p>The arithmetic mean after \(n\) observations is:</p>
        <div class="display-equation">\(\displaystyle \mu_n = \frac{1}{n}\sum_{i=1}^n x_i.\)</div>
        <p>Separating the last term gives:</p>
        <div class="display-equation">\(\displaystyle \mu_n = \frac{1}{n}\left(\sum_{i=1}^{n-1} x_i + x_n\right)=\frac{n-1}{n}\mu_{n-1} + \frac{1}{n}x_n.\)</div>
        <p>Simplifying:</p>
        <div class="display-equation">\(\displaystyle \mu_n = \mu_{n-1} + \frac{x_n - \mu_{n-1}}{n}.\)</div>
        <p>This recurrence updates the mean incrementally (O(1) per element).</p>

        <h3>2) Variance recurrence (compact derivation — Welford)</h3>
        <p>Define the corrected second moment ("M2") as</p>
        <div class="display-equation">\(\displaystyle M2_n = \sum_{i=1}^n (x_i - \mu_n)^2.\)</div>
        <p>We denote \(\delta = x_n - \mu_{n-1}\) and use \(\mu_n = \mu_{n-1} + \delta/n\).</p>
        <p>Expanding the sum and simplifying (cross terms cancel by the mean definition) gives the compact identity:</p>
        <div class="display-equation">\(\displaystyle M2_n = M2_{n-1} + \delta\cdot(x_n - \mu_n).\)</div>
        <p>The unbiased sample variance is therefore</p>
        <div class="display-equation">\(\displaystyle s^2 = \frac{M2_n}{n-1},\quad n\ge 2.\)</div>
        <p>These formulas are the basis of Welford's algorithm: O(1) per element and numerically stable because they avoid subtracting two large, similar numbers.</p>
      </article>

      <article class="card" aria-labelledby="howto-title">
        <h2 id="howto-title">How to use (modes)</h2>
        <ol>
          <li><strong>Step-by-step (recommended)</strong>: enter values one at a time with <em>Add value</em>. This demonstrates the incremental update.</li>
          <li><strong>Vector mode</strong>: paste a comma-separated list; the page will still process values element-by-element using the online algorithm (not a batch operation).</li>
          <li>The <strong>Benchmark</strong> section compares two online methods: Welford (stable) and the simple <code>sum</code> &amp; <code>sumsq</code> approach (faster but less robust numerically).</li>
        </ol>
      </article>

      <section class="card layout" aria-labelledby="sim-title">
        <div>
          <h2 id="sim-title">Simulator — Input & Controls (online)</h2>

          <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btn" id="btnWhole" aria-pressed="true">Enter Vector</button>
            <button class="btn ghost" id="btnStep" aria-pressed="false">Enter Values</button>
            <button class="btn ghost" id="btnResetAll">Reset All</button>
          </div>

          <div id="wholePanel" style="margin-top:12px;">
            <label for="vectorInput">Paste numbers separated by commas</label>
            <textarea id="vectorInput" rows="3" placeholder="e.g. 1, 2, 3.5, 4"></textarea>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button class="btn" id="calcVector">Process (as stream)</button>
              <button class="btn ghost" id="clearVector">Clear</button>
            </div>
          </div>

          <div id="stepPanel" style="margin-top:12px; display:none;">
            <label for="singleValue">Single value</label>
            <input id="singleValue" type="number" inputmode="decimal" placeholder="Enter a number and press Add" />
            <div style="display:flex;gap:8px;margin-top:8px">
              <button class="btn" id="addValue">Add value</button>
              <button class="btn ghost" id="resetValues">Reset values</button>
              <button class="btn ghost" id="exportCSV">Export CSV</button>
            </div>
            <div class="values-list" id="valuesList" aria-live="polite">Current data: []</div>
          </div>

          <div style="margin-top:12px" class="code" id="resultBox">
            <strong>Results:</strong>
            <div id="results" style="margin-top:8px;color:var(--mono)">No calculation performed yet.</div>
          </div>
        </div>

        <aside>
          <h3>Charts</h3>
          <div class="chart" style="margin-top:8px">
            <canvas id="cumMeanChart" aria-label="Cumulative mean chart"></canvas>
            <div class="small muted" style="margin-top:6px">Cumulative mean with ±1 standard error (dashed lines).</div>
          </div>

          <div class="chart" style="margin-top:12px">
            <canvas id="runningVarChart" aria-label="Running variance chart"></canvas>
            <div class="small muted" style="margin-top:6px">Running (sample) variance vs n — useful to check stability.</div>
          </div>

          <div class="chart" style="margin-top:12px">
            <canvas id="histChart" aria-label="Histogram of values"></canvas>
            <div class="small muted" style="margin-top:6px">Histogram with kernel density estimate overlay.</div>
          </div>
        </aside>
      </section>

      <article class="card" aria-labelledby="hw-title">
        <h2 id="hw-title">Optional Homework — comparing online methods</h2>
        <p class="small muted">Goal: prove the recurrences, test online algorithms, and show the numerical advantages of Welford over simple incremental <code>sum</code> &amp; <code>sumsq</code>.</p>

        <div class="code" style="margin-top:12px">
          <label>Benchmark parameters</label>
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
            <input id="benchN" type="number" value="200000" />
            <input id="benchTrials" type="number" value="3" />
            <select id="benchDist">
              <option value="normal">Normal(0,1)</option>
              <option value="uniform">Uniform(0,1)</option>
              <option value="large">Large magnitude (1e8 + small noise)</option>
            </select>
            <button class="btn" id="runBench">Run benchmark</button>
          </div>
          <div style="margin-top:10px" class="small muted">N = number of elements, Trials = how many runs to average.</div>
        </div>

        <div style="margin-top:12px" class="card">
          <h3>Benchmark results (online methods)</h3>
          <div id="benchResults">Press <strong>Run benchmark</strong> to execute. Charts show timings and numeric differences against Welford.</div>
          <div style="margin-top:8px" class="chart"><canvas id="timeChart"></canvas></div>
          <div style="margin-top:8px" class="chart"><canvas id="errChart"></canvas></div>
        </div>
      </article>

      <article class="card" aria-labelledby="desc-title">
        <h2 id="desc-title">Numerical discussion (brief)</h2>
        <p>Main advantages of online (Welford) algorithms:</p>
        <ul>
          <li><strong>Numerical stability</strong>: avoids cancellation between large, similar numbers.</li>
          <li><strong>Low memory</strong>: O(1) extra space, suitable for streams and very large datasets.</li>
          <li><strong>Mergeability</strong>: statistics can be combined pairwise for distributed computation without losing precision.</li>
          <li><strong>Efficiency</strong>: O(1) updates per element and O(n) total time.</li>
        </ul>
        <p>The naive <code>sum</code> &amp; <code>sumsq</code> approach is slightly faster but vulnerable to precision loss and even overflow for large-magnitude inputs. The benchmark demonstrates this trade-off.</p>
      </article>

    </main>

    <footer class="small muted">© 2025 Riccardo D'Annibale — corrected version (online algorithms)</footer>
  </div>

  <script>
    // Helper short selector
    const $ = id => document.getElementById(id);

    // State
    let values = [];
    let cumChart = null, histChart = null, timeChart = null, errChart = null, runningVarChart = null, lastExport = null;

    // Simple Gaussian kernel density
    function kernelDensity(xs, data, bandwidth){
      const out = new Array(xs.length).fill(0);
      const n = data.length;
      if(n === 0) return out;
      const invSqrt2pi = 1/Math.sqrt(2*Math.PI);
      for(let i=0;i<xs.length;i++){
        const x = xs[i];
        let s = 0;
        for(let j=0;j<n;j++){
          const u = (x - data[j]) / bandwidth;
          s += Math.exp(-0.5*u*u) * invSqrt2pi;
        }
        out[i] = s / (n * bandwidth);
      }
      return out;
    }

    function initCharts(){
      if(cumChart) cumChart.destroy();
      if(histChart) histChart.destroy();
      if(timeChart) timeChart.destroy();
      if(errChart) errChart.destroy();
      if(runningVarChart) runningVarChart.destroy();

      const ctx1 = $('cumMeanChart').getContext('2d');
      cumChart = new Chart(ctx1, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            { label: 'Cumulative mean', data: [], borderWidth: 2, tension: 0.18, fill: false, pointRadius: 0, borderColor: 'rgba(76,175,80,0.9)' },
            { label: '±1 SE (upper)', data: [], borderWidth: 1, tension: 0.18, pointRadius: 0, borderDash: [6,4], fill: false, borderColor: 'rgba(159,184,159,0.7)' },
            { label: '±1 SE (lower)', data: [], borderWidth: 1, tension: 0.18, pointRadius: 0, borderDash: [6,4], fill: false, borderColor: 'rgba(159,184,159,0.7)' }
          ]
        },
        options: { responsive: true, maintainAspectRatio: false, animation: false, interaction: { mode: 'index', intersect: false }, plugins: { legend: { display: false } }, scales: { x: { title: { display: true, text: 'Index (k)' } }, y: { title: { display: true, text: 'Cumulative mean' } } } }
      });

      const ctxRv = $('runningVarChart').getContext('2d');
      runningVarChart = new Chart(ctxRv, {
        type: 'line',
        data: { labels: [], datasets: [ { label: 'Running sample variance (s^2)', data: [], borderWidth: 2, tension: 0.18, pointRadius: 0 } ] },
        options: { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display: false } }, scales: { x: { title: { display: true, text: 'Index (k)' } }, y: { title: { display: true, text: 'Running sample variance' }, beginAtZero: true } } }
      });

      const ctx2 = $('histChart').getContext('2d');
      histChart = new Chart(ctx2, {
        type: 'bar',
        data: { labels: [], datasets: [ { label: 'Count', data: [], barThickness: 'flex' }, { label: 'KDE', data: [], type: 'line', borderWidth: 2, pointRadius: 0, tension: 0.35 } ] },
        options: { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display: false }, tooltip: { mode: 'index', intersect: false } }, scales: { y: { beginAtZero: true, title: { display: true, text: 'count / density' } } } }
      });

      const ctx3 = $('timeChart').getContext('2d');
      timeChart = new Chart(ctx3, {
        type: 'bar',
        data: { labels: ['Welford (online stable)','Sum/Sumsq (online unstable)'], datasets: [{ label: 'ms per run (avg)', data: [0,0], barThickness: 36 }] },
        options: { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => `${ctx.dataset.label}: ${ctx.formattedValue} ms` } } }, scales: { y: { beginAtZero: true, title: { display: true, text: 'milliseconds' } } } }
      });

      const ctx4 = $('errChart').getContext('2d');
      errChart = new Chart(ctx4, {
        type: 'bar',
        data: { labels: ['|Var_sum - Var_welford|'], datasets: [{ label: 'absolute difference', data: [1e-300], barThickness: 40 }] },
        options: { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true, title: { display: true, text: 'absolute value' }, type: 'logarithmic', ticks: { callback: function(value){ try { return Number(value).toExponential(1); } catch(e){ return value; } } } } } }
      });
    }
    initCharts();

    // Statistics: only online implementations (Welford + simple sum/sumsq online for comparison)
    function welfordOnlineFromArray(arr){
      let n = 0, mu = 0, M2 = 0;
      for(const x of arr){
        n++;
        const delta = x - mu;
        mu += delta / n;
        M2 += delta * (x - mu);
      }
      return { mean: n ? mu : NaN, variance: n > 1 ? (M2 / (n - 1)) : NaN };
    }

    // Simple online accumulator: maintain sum and sumsq incrementally
    function sumSumsqOnlineFromArray(arr){
      let n = 0, s = 0, ss = 0;
      for(const x of arr){
        n++;
        s += x;
        ss += x * x;
      }
      if(n === 0) return { mean: NaN, variance: NaN };
      const m = s / n;
      return { mean: m, variance: n > 1 ? ((ss - n * m * m) / (n - 1)) : NaN };
    }

    function runningStatsWelford(arr){
      const n = arr.length;
      const means = new Array(n);
      const vars = new Array(n);
      let count = 0, mu = 0, M2 = 0;
      for(let i=0;i<n;i++){
        const x = arr[i];
        count++;
        const delta = x - mu;
        mu += delta / count;
        M2 += delta * (x - mu);
        means[i] = mu;
        vars[i] = (count > 1) ? (M2 / (count - 1)) : NaN;
      }
      return { means, vars };
    }

    function updateUI(){
      $('valuesList').textContent = `Current data: [${values.slice(0,200).join(', ')}${values.length > 200 ? ', ...' : ''}]`;

      if(values.length === 0){
        $('results').innerHTML = `<em>No data available.</em>`;
        updateCharts([], [], { labels: [], counts: [] }, null);
        lastExport = null;
        return;
      }

      const rW = welfordOnlineFromArray(values);
      const m = rW.mean;
      const s2 = rW.variance;
      const n = values.length;
      const mStr = Number.isFinite(m) ? m.toFixed(6) : 'N/A';
      const vStr = Number.isFinite(s2) ? s2.toExponential(6) : 'N/A (needs n≥2)';
      $('results').innerHTML = `<div><strong>n</strong>: ${n}</div><div><strong>Mean</strong>: ${mStr}</div><div><strong>Sample variance</strong>: ${vStr}</div>`;

      const run = runningStatsWelford(values);
      const cumMeans = run.means;
      const runVars = run.vars;

      const se = cumMeans.map((_, i) => { const v = runVars[i]; return (i+1 > 1 && Number.isFinite(v)) ? Math.sqrt(v / (i+1)) : NaN; });

      const bins = Math.min(40, Math.max(6, Math.ceil(Math.sqrt(values.length))));
      const minV = Math.min(...values);
      const maxV = Math.max(...values);
      const range = (maxV - minV) || 1;
      const counts = new Array(bins).fill(0);
      const binCenters = new Array(bins);
      for(let x of values){
        let idx = Math.floor(((x - minV) / range) * bins);
        if(idx < 0) idx = 0;
        if(idx >= bins) idx = bins - 1;
        counts[idx]++;
      }
      for(let i=0;i<bins;i++){
        const a = (minV + (i / bins) * range);
        const b = (minV + ((i + 1) / bins) * range);
        binCenters[i] = (a + b) / 2;
      }

      const gridSize = 200;
      const grid = new Array(gridSize);
      for(let i=0;i<gridSize;i++) grid[i] = minV + (i / (gridSize - 1)) * range;

      const bandwidth = (function(){
        const n = values.length;
        if(n < 2) return 0.1;
        const meanVal = values.reduce((a,b)=>a+b,0)/n;
        let s = 0;
        for(const v of values) s += (v - meanVal) * (v - meanVal);
        const sd = Math.sqrt(s / (n - 1));
        return Math.max(sd * Math.pow(n, -1/5), 1e-6);
      })();

      const kde = kernelDensity(grid, values, Math.max(bandwidth, 1e-6));
      const histLabels = binCenters.map(c => c.toFixed(2));

      updateCharts(cumMeans, runVars, { labels: histLabels, counts }, { grid, kde, gridMin: grid[0], gridMax: grid[grid.length - 1] }, se);
      lastExport = { values: values.slice(), mean: m, variance: s2 };
    }

    function updateCharts(cumMeans, runVars, hist, kdeData, se){
      cumChart.data.labels = cumMeans.map((_, i) => i + 1);
      cumChart.data.datasets[0].data = cumMeans.map(v => Number.isFinite(v) ? v : null);

      const upper = cumMeans.map((m, i) => (Number.isFinite(m) && se && Number.isFinite(se[i])) ? (m + se[i]) : null);
      const lower = cumMeans.map((m, i) => (Number.isFinite(m) && se && Number.isFinite(se[i])) ? (m - se[i]) : null);

      cumChart.data.datasets[1].data = upper;
      cumChart.data.datasets[2].data = lower;
      cumChart.update();

      if(runningVarChart){
        runningVarChart.data.labels = cumMeans.map((_, i) => i + 1);
        runningVarChart.data.datasets[0].data = runVars.map(v => Number.isFinite(v) ? v : null);
        runningVarChart.update();
      }

      if(histChart){
        histChart.data.labels = hist.labels;
        histChart.data.datasets[0].data = hist.counts;
        if(kdeData && kdeData.kde && kdeData.kde.length){
          const maxCount = Math.max(...hist.counts, 1);
          const kdeMax = Math.max(...kdeData.kde, 1e-12);
          const scale = maxCount / kdeMax;
          const sampled = hist.labels.map((lab, i) => {
            const center = Number(lab);
            const idx = Math.round((center - kdeData.gridMin) / (kdeData.gridMax - kdeData.gridMin) * (kdeData.kde.length - 1));
            const clamped = Math.max(0, Math.min(kdeData.kde.length - 1, idx));
            return kdeData.kde[clamped] * scale;
          });
          histChart.data.datasets[1].data = sampled;
        } else {
          histChart.data.datasets[1].data = [];
        }
        histChart.update();
      }
    }

    // UI events
    $('btnWhole').addEventListener('click', ()=>{
      $('wholePanel').style.display = 'block';
      $('stepPanel').style.display = 'none';
      $('btnWhole').classList.remove('ghost');
      $('btnStep').classList.add('ghost');
      $('btnWhole').setAttribute('aria-pressed','true');
      $('btnStep').setAttribute('aria-pressed','false');
    });
    $('btnStep').addEventListener('click', ()=>{
      $('wholePanel').style.display = 'none';
      $('stepPanel').style.display = 'block';
      $('btnStep').classList.remove('ghost');
      $('btnWhole').classList.add('ghost');
      $('btnStep').setAttribute('aria-pressed','true');
      $('btnWhole').setAttribute('aria-pressed','false');
    });

    $('clearVector').addEventListener('click', ()=>{ $('vectorInput').value = ''; });
    $('calcVector').addEventListener('click', ()=>{
      const raw = $('vectorInput').value.trim();
      if(!raw){ alert('Please enter some numbers separated by commas.'); return; }
      const parts = raw.split(',').map(s => s.trim()).filter(s => s !== '');
      const arr = parts.map(s => Number(s.replace(',', '.'))).filter(x => !Number.isNaN(x));
      if(arr.length === 0){ alert('No valid numbers found. Check syntax (use commas to separate).'); return; }
      // Process as a stream using the online algorithm: we still store values for plotting, but statistics are computed online
      values = []; // reset and feed one by one to mirror streaming
      for(const x of arr){ values.push(x); }
      updateUI();
    });

    $('addValue').addEventListener('click', ()=>{
      const v = $('singleValue').value;
      if(v === '') { alert('Please enter a number before adding.'); return; }
      const num = Number(String(v).replace(',', '.'));
      if(Number.isNaN(num)){ alert('Invalid value.'); return; }
      values.push(num);
      $('singleValue').value = '';
      updateUI();
    });

    $('resetValues').addEventListener('click', ()=>{ values = []; updateUI(); });
    $('btnResetAll').addEventListener('click', ()=>{
      if(!confirm('Reset the simulator and delete all data?')) return;
      values = [];
      $('vectorInput').value = '';
      $('singleValue').value = '';
      updateUI();
    });

    $('exportCSV').addEventListener('click', ()=>{
      if(!lastExport || !lastExport.values || lastExport.values.length === 0){ alert('Run at least one input / calculation before exporting.'); return; }
      let csv = 'index,value\n';
      for(let i=0;i<lastExport.values.length;i++){ csv += `${i+1},${lastExport.values[i]}\n`; }
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url;
      const now = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
      a.download = `values_export_${now}.csv`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // Benchmark utilities (compare two online methods)
    function randNormal(){
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }
    function generateArray(n, dist){
      const arr = new Array(n);
      if(dist === 'normal'){ for(let i=0;i<n;i++) arr[i] = randNormal(); }
      else if(dist === 'uniform'){ for(let i=0;i<n;i++) arr[i] = Math.random(); }
      else if(dist === 'large'){ for(let i=0;i<n;i++) arr[i] = 1e8 + (randNormal() * 1e-2); }
      return arr;
    }

    function timeFn(fn, arr, trials){
      for(let i=0;i<4;i++) fn(arr);
      const t0 = performance.now();
      for(let i=0;i<trials;i++) fn(arr);
      const t1 = performance.now();
      return (t1 - t0) / trials;
    }

    $('runBench').addEventListener('click', ()=>{
      const n = Math.max(1, Number($('benchN').value) || 100000);
      const trials = Math.max(1, Number($('benchTrials').value) || 3);
      const dist = $('benchDist').value;
      $('benchResults').textContent = `Generating vector N=${n} (${dist})...`;
      $('runBench').disabled = true;
      setTimeout(()=>{
        const arr = generateArray(n, dist);
        $('benchResults').textContent = `Running benchmark on N=${n} (avg of ${trials} runs)...`;

        const tWelf = timeFn(welfordOnlineFromArray, arr, trials);
        const tSum = timeFn(sumSumsqOnlineFromArray, arr, trials);

        const rW = welfordOnlineFromArray(arr);
        const rS = sumSumsqOnlineFromArray(arr);

        const varDiff = Number.isFinite(rS.variance) && Number.isFinite(rW.variance) ? Math.abs(rS.variance - rW.variance) : NaN;

        timeChart.data.datasets[0].data = [ Number(tWelf.toFixed(3)), Number(tSum.toFixed(3)) ];
        timeChart.update();

        errChart.data.datasets[0].data = [ (Number.isFinite(varDiff) && varDiff > 0) ? varDiff : 1e-300 ];
        errChart.update();

        $('benchResults').innerHTML = `
          <table>
            <thead><tr><th>Method</th><th>ms/run (avg)</th><th>Mean</th><th>Variance</th></tr></thead>
            <tbody>
              <tr><td>Welford (online, stable)</td><td>${tWelf.toFixed(3)}</td><td>${rW.mean}</td><td>${rW.variance}</td></tr>
              <tr><td>Sum &amp; SumSq (online, unstable)</td><td>${tSum.toFixed(3)}</td><td>${rS.mean}</td><td>${rS.variance}</td></tr>
            </tbody>
          </table>
          <div style="margin-top:8px" class="small muted">Difference in variance: |Var_sum - Var_welford| = ${varDiff}</div>
        `;
        $('runBench').disabled = false;
      }, 50);
    });

    // Initial UI
    updateUI();
    document.addEventListener('DOMContentLoaded', ()=>{
      if(window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise().catch(()=>{});
    });
    window.addEventListener('resize', ()=>{
      if(cumChart) cumChart.resize();
      if(histChart) histChart.resize();
      if(timeChart) timeChart.resize();
      if(errChart) errChart.resize();
      if(runningVarChart) runningVarChart.resize();
    });
  </script>
</body>
</html>
